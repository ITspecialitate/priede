//! Module for the lexer and parser for priede
//! WARNING: this file has been generated by
//! Hime Parser Generator 3.5.1.0

use std::io::Read;

use hime_redist::ast::AstNode;
use hime_redist::errors::ParseErrors;
use hime_redist::lexers::automaton::Automaton;
use hime_redist::lexers::impls::ContextFreeLexer;
use hime_redist::parsers::Parser;
use hime_redist::parsers::lrk::LRkAutomaton;
use hime_redist::parsers::lrk::LRkParser;
use hime_redist::result::ParseResult;
use hime_redist::symbols::SemanticBody;
use hime_redist::symbols::SemanticElementTrait;
use hime_redist::symbols::Symbol;
use hime_redist::text::Text;
use hime_redist::tokens::TokenRepository;
use hime_redist::utils::iterable::Iterable;

/// Static resource for the serialized lexer automaton
const LEXER_AUTOMATON: &[u8] = include_bytes!("priedeLexer.bin");

/// The unique identifier for terminal WHITE_SPACE
pub const ID_TERMINAL_WHITE_SPACE: u32 = 0x0003;
/// The unique identifier for terminal LineTerminator
pub const ID_TERMINAL_LINE_TERMINATOR: u32 = 0x0004;
/// The unique identifier for terminal CommentLine
pub const ID_TERMINAL_COMMENT_LINE: u32 = 0x0005;
/// The unique identifier for terminal CommentBlock
pub const ID_TERMINAL_COMMENT_BLOCK: u32 = 0x0006;
/// The unique identifier for terminal SEPARATOR
pub const ID_TERMINAL_SEPARATOR: u32 = 0x0007;
/// The unique identifier for terminal ID
pub const ID_TERMINAL_ID: u32 = 0x0008;
/// The unique identifier for terminal QUOTE
pub const ID_TERMINAL_QUOTE: u32 = 0x0009;
/// The unique identifier for terminal INTEGER
pub const ID_TERMINAL_INTEGER: u32 = 0x000A;
/// The unique identifier for terminal NUMBER
pub const ID_TERMINAL_NUMBER: u32 = 0x000B;
/// The unique identifier for terminal STRING
pub const ID_TERMINAL_STRING: u32 = 0x000C;

/// The unique identifier for the default context
pub const CONTEXT_DEFAULT: u16 = 0;

/// The collection of terminals matched by this lexer
/// The terminals are in an order consistent with the automaton,
/// so that terminal indices in the automaton can be used to retrieve the terminals in this table
const TERMINALS: &[Symbol] = &[
    Symbol { id: 0x0001, name: "ε" },
    Symbol { id: 0x0002, name: "$" },
    Symbol { id: 0x0003, name: "WHITE_SPACE" },
    Symbol { id: 0x0004, name: "LineTerminator" },
    Symbol { id: 0x0005, name: "CommentLine" },
    Symbol { id: 0x0006, name: "CommentBlock" },
    Symbol { id: 0x0007, name: "SEPARATOR" },
    Symbol { id: 0x0008, name: "ID" },
    Symbol { id: 0x0009, name: "QUOTE" },
    Symbol { id: 0x000A, name: "INTEGER" },
    Symbol { id: 0x000B, name: "NUMBER" },
    Symbol { id: 0x000C, name: "STRING" },
    Symbol { id: 0x002A, name: "būls" },
    Symbol { id: 0x002B, name: "teksts" },
    Symbol { id: 0x002C, name: "sk" },
    Symbol { id: 0x002D, name: "lsk" },
    Symbol { id: 0x002E, name: "natsk" },
    Symbol { id: 0x002F, name: "lnatsk" },
    Symbol { id: 0x0030, name: "PAT" },
    Symbol { id: 0x0031, name: "PATIESS" },
    Symbol { id: 0x0032, name: "NEPAT" },
    Symbol { id: 0x0033, name: "NEPATIESS" },
    Symbol { id: 0x0034, name: "->" },
    Symbol { id: 0x0035, name: "-+>" },
    Symbol { id: 0x0036, name: "-->" },
    Symbol { id: 0x0037, name: "-*>" },
    Symbol { id: 0x0038, name: "-/>" },
    Symbol { id: 0x0039, name: "(" },
    Symbol { id: 0x003A, name: ")" },
    Symbol { id: 0x003B, name: "()" },
    Symbol { id: 0x003C, name: "," },
    Symbol { id: 0x003E, name: "=" },
    Symbol { id: 0x003F, name: ">" },
    Symbol { id: 0x0040, name: ">=" },
    Symbol { id: 0x0041, name: "<" },
    Symbol { id: 0x0042, name: "!=" },
    Symbol { id: 0x0043, name: "vai" },
    Symbol { id: 0x0044, name: "un" },
    Symbol { id: 0x0045, name: "ja" },
    Symbol { id: 0x0046, name: "{" },
    Symbol { id: 0x0047, name: "}" },
    Symbol { id: 0x0048, name: "citādi" },
    Symbol { id: 0x0049, name: "*" },
    Symbol { id: 0x004A, name: "/" },
    Symbol { id: 0x004B, name: "+" },
    Symbol { id: 0x004C, name: "-" }];

/// Creates a new lexer
fn new_lexer<'a>(
    repository: TokenRepository<'a>,
    errors: &'a mut ParseErrors
) -> ContextFreeLexer<'a> {
    let automaton = Automaton::new(LEXER_AUTOMATON);
    ContextFreeLexer::new(repository, errors, automaton, 0x0007)
}

/// Static resource for the serialized parser automaton
const PARSER_AUTOMATON: &[u8] = include_bytes!("priedeParser.bin");

/// The unique identifier for variable BOOL_DEF
pub const ID_VARIABLE_BOOL_DEF: u32 = 0x000D;
/// The unique identifier for variable TEXT
pub const ID_VARIABLE_TEXT: u32 = 0x000E;
/// The unique identifier for variable NUM
pub const ID_VARIABLE_NUM: u32 = 0x000F;
/// The unique identifier for variable LONG
pub const ID_VARIABLE_LONG: u32 = 0x0010;
/// The unique identifier for variable NATURAL
pub const ID_VARIABLE_NATURAL: u32 = 0x0011;
/// The unique identifier for variable LONG_NAT
pub const ID_VARIABLE_LONG_NAT: u32 = 0x0012;
/// The unique identifier for variable TYPE
pub const ID_VARIABLE_TYPE: u32 = 0x0013;
/// The unique identifier for variable TRUE
pub const ID_VARIABLE_TRUE: u32 = 0x0014;
/// The unique identifier for variable FALSE
pub const ID_VARIABLE_FALSE: u32 = 0x0015;
/// The unique identifier for variable BOOL
pub const ID_VARIABLE_BOOL: u32 = 0x0016;
/// The unique identifier for variable var_def
pub const ID_VARIABLE_VAR_DEF: u32 = 0x0017;
/// The unique identifier for variable var_def_value
pub const ID_VARIABLE_VAR_DEF_VALUE: u32 = 0x0018;
/// The unique identifier for variable asignable_exp
pub const ID_VARIABLE_ASIGNABLE_EXP: u32 = 0x0019;
/// The unique identifier for variable assign_op
pub const ID_VARIABLE_ASSIGN_OP: u32 = 0x001A;
/// The unique identifier for variable id_asign
pub const ID_VARIABLE_ID_ASIGN: u32 = 0x001B;
/// The unique identifier for variable func_call
pub const ID_VARIABLE_FUNC_CALL: u32 = 0x001C;
/// The unique identifier for variable funcargs
pub const ID_VARIABLE_FUNCARGS: u32 = 0x001D;
/// The unique identifier for variable comp_s
pub const ID_VARIABLE_COMP_S: u32 = 0x001E;
/// The unique identifier for variable vai
pub const ID_VARIABLE_VAI: u32 = 0x001F;
/// The unique identifier for variable un
pub const ID_VARIABLE_UN: u32 = 0x0020;
/// The unique identifier for variable comp
pub const ID_VARIABLE_COMP: u32 = 0x0021;
/// The unique identifier for variable if
pub const ID_VARIABLE_IF: u32 = 0x0022;
/// The unique identifier for variable exp_atom
pub const ID_VARIABLE_EXP_ATOM: u32 = 0x0023;
/// The unique identifier for variable exp_reizdal
pub const ID_VARIABLE_EXP_REIZDAL: u32 = 0x0024;
/// The unique identifier for variable exp_plusmin
pub const ID_VARIABLE_EXP_PLUSMIN: u32 = 0x0025;
/// The unique identifier for variable exp
pub const ID_VARIABLE_EXP: u32 = 0x0026;
/// The unique identifier for variable stat
pub const ID_VARIABLE_STAT: u32 = 0x0027;
/// The unique identifier for variable block
pub const ID_VARIABLE_BLOCK: u32 = 0x0028;
/// The unique identifier for variable root
pub const ID_VARIABLE_ROOT: u32 = 0x0029;


/// The collection of variables matched by this parser
/// The variables are in an order consistent with the automaton,
/// so that variable indices in the automaton can be used to retrieve the variables in this table
const VARIABLES: &[Symbol] = &[
    Symbol { id: 0x000D, name: "BOOL_DEF" },
    Symbol { id: 0x000E, name: "TEXT" },
    Symbol { id: 0x000F, name: "NUM" },
    Symbol { id: 0x0010, name: "LONG" },
    Symbol { id: 0x0011, name: "NATURAL" },
    Symbol { id: 0x0012, name: "LONG_NAT" },
    Symbol { id: 0x0013, name: "TYPE" },
    Symbol { id: 0x0014, name: "TRUE" },
    Symbol { id: 0x0015, name: "FALSE" },
    Symbol { id: 0x0016, name: "BOOL" },
    Symbol { id: 0x0017, name: "var_def" },
    Symbol { id: 0x0018, name: "var_def_value" },
    Symbol { id: 0x0019, name: "asignable_exp" },
    Symbol { id: 0x001A, name: "assign_op" },
    Symbol { id: 0x001B, name: "id_asign" },
    Symbol { id: 0x001C, name: "func_call" },
    Symbol { id: 0x001D, name: "funcargs" },
    Symbol { id: 0x001E, name: "comp_s" },
    Symbol { id: 0x001F, name: "vai" },
    Symbol { id: 0x0020, name: "un" },
    Symbol { id: 0x0021, name: "comp" },
    Symbol { id: 0x0022, name: "if" },
    Symbol { id: 0x0023, name: "exp_atom" },
    Symbol { id: 0x0024, name: "exp_reizdal" },
    Symbol { id: 0x0025, name: "exp_plusmin" },
    Symbol { id: 0x0026, name: "exp" },
    Symbol { id: 0x0027, name: "stat" },
    Symbol { id: 0x0028, name: "block" },
    Symbol { id: 0x0029, name: "root" },
    Symbol { id: 0x003D, name: "__V61" },
    Symbol { id: 0x004D, name: "__V77" },
    Symbol { id: 0x004E, name: "__VAxiom" }];

/// The collection of virtuals matched by this parser
/// The virtuals are in an order consistent with the automaton,
/// so that virtual indices in the automaton can be used to retrieve the virtuals in this table
const VIRTUALS: &[Symbol] = &[
];

/// Parses the specified string with this parser
pub fn parse_string(input: &str) -> ParseResult {
    let text = Text::new(input);
    parse_text(text)
}

/// Parses the specified stream of UTF-16 with this parser
pub fn parse_utf16(input: &mut dyn Read, big_endian: bool) -> ParseResult {
    let text = Text::from_utf16_stream(input, big_endian);
    parse_text(text)
}

/// Parses the specified stream of UTF-16 with this parser
pub fn parse_utf8(input: &mut dyn Read) -> ParseResult {
    let text = Text::from_utf8_stream(input);
    parse_text(text)
}

/// Parses the specified text with this parser
fn parse_text(text: Text) -> ParseResult {
    let mut my_actions = |_index: usize, _head: Symbol, _body: &dyn SemanticBody| ();
    let mut result = ParseResult::new(TERMINALS, VARIABLES, VIRTUALS, text);
    {
        let data = result.get_parsing_data();
        let mut lexer = new_lexer(data.0, data.1);
        let automaton = LRkAutomaton::new(PARSER_AUTOMATON);
        let mut parser = LRkParser::new(&mut lexer, automaton, data.2, &mut my_actions);
        parser.parse();
    }
    result
}

/// Visitor interface
pub trait Visitor {
    fn on_terminal_white_space(&self, _node: &AstNode) {}
    fn on_terminal_line_terminator(&self, _node: &AstNode) {}
    fn on_terminal_comment_line(&self, _node: &AstNode) {}
    fn on_terminal_comment_block(&self, _node: &AstNode) {}
    fn on_terminal_separator(&self, _node: &AstNode) {}
    fn on_terminal_id(&self, _node: &AstNode) {}
    fn on_terminal_quote(&self, _node: &AstNode) {}
    fn on_terminal_integer(&self, _node: &AstNode) {}
    fn on_terminal_number(&self, _node: &AstNode) {}
    fn on_terminal_string(&self, _node: &AstNode) {}
    fn on_variable_bool_def(&self, _node: &AstNode) {}
    fn on_variable_text(&self, _node: &AstNode) {}
    fn on_variable_num(&self, _node: &AstNode) {}
    fn on_variable_long(&self, _node: &AstNode) {}
    fn on_variable_natural(&self, _node: &AstNode) {}
    fn on_variable_long_nat(&self, _node: &AstNode) {}
    fn on_variable_type(&self, _node: &AstNode) {}
    fn on_variable_true(&self, _node: &AstNode) {}
    fn on_variable_false(&self, _node: &AstNode) {}
    fn on_variable_bool(&self, _node: &AstNode) {}
    fn on_variable_var_def(&self, _node: &AstNode) {}
    fn on_variable_var_def_value(&self, _node: &AstNode) {}
    fn on_variable_asignable_exp(&self, _node: &AstNode) {}
    fn on_variable_assign_op(&self, _node: &AstNode) {}
    fn on_variable_id_asign(&self, _node: &AstNode) {}
    fn on_variable_func_call(&self, _node: &AstNode) {}
    fn on_variable_funcargs(&self, _node: &AstNode) {}
    fn on_variable_comp_s(&self, _node: &AstNode) {}
    fn on_variable_vai(&self, _node: &AstNode) {}
    fn on_variable_un(&self, _node: &AstNode) {}
    fn on_variable_comp(&self, _node: &AstNode) {}
    fn on_variable_if(&self, _node: &AstNode) {}
    fn on_variable_exp_atom(&self, _node: &AstNode) {}
    fn on_variable_exp_reizdal(&self, _node: &AstNode) {}
    fn on_variable_exp_plusmin(&self, _node: &AstNode) {}
    fn on_variable_exp(&self, _node: &AstNode) {}
    fn on_variable_stat(&self, _node: &AstNode) {}
    fn on_variable_block(&self, _node: &AstNode) {}
    fn on_variable_root(&self, _node: &AstNode) {}
}

/// Walk the AST of a result using a visitor
pub fn visit(result: &ParseResult, visitor: &dyn Visitor) {
    let ast = result.get_ast();
    let root = ast.get_root();
    visit_ast_node(root, visitor);
}

/// Walk the sub-AST from the specified node using a visitor
pub fn visit_ast_node<'a>(node: AstNode<'a>, visitor: &dyn Visitor) {
    let children = node.children();
    for child in children.iter() {
        visit_ast_node(child, visitor);
    }
    match node.get_symbol().id {
        0x0003 => visitor.on_terminal_white_space(&node),
        0x0004 => visitor.on_terminal_line_terminator(&node),
        0x0005 => visitor.on_terminal_comment_line(&node),
        0x0006 => visitor.on_terminal_comment_block(&node),
        0x0007 => visitor.on_terminal_separator(&node),
        0x0008 => visitor.on_terminal_id(&node),
        0x0009 => visitor.on_terminal_quote(&node),
        0x000A => visitor.on_terminal_integer(&node),
        0x000B => visitor.on_terminal_number(&node),
        0x000C => visitor.on_terminal_string(&node),
        0x000D => visitor.on_variable_bool_def(&node),
        0x000E => visitor.on_variable_text(&node),
        0x000F => visitor.on_variable_num(&node),
        0x0010 => visitor.on_variable_long(&node),
        0x0011 => visitor.on_variable_natural(&node),
        0x0012 => visitor.on_variable_long_nat(&node),
        0x0013 => visitor.on_variable_type(&node),
        0x0014 => visitor.on_variable_true(&node),
        0x0015 => visitor.on_variable_false(&node),
        0x0016 => visitor.on_variable_bool(&node),
        0x0017 => visitor.on_variable_var_def(&node),
        0x0018 => visitor.on_variable_var_def_value(&node),
        0x0019 => visitor.on_variable_asignable_exp(&node),
        0x001A => visitor.on_variable_assign_op(&node),
        0x001B => visitor.on_variable_id_asign(&node),
        0x001C => visitor.on_variable_func_call(&node),
        0x001D => visitor.on_variable_funcargs(&node),
        0x001E => visitor.on_variable_comp_s(&node),
        0x001F => visitor.on_variable_vai(&node),
        0x0020 => visitor.on_variable_un(&node),
        0x0021 => visitor.on_variable_comp(&node),
        0x0022 => visitor.on_variable_if(&node),
        0x0023 => visitor.on_variable_exp_atom(&node),
        0x0024 => visitor.on_variable_exp_reizdal(&node),
        0x0025 => visitor.on_variable_exp_plusmin(&node),
        0x0026 => visitor.on_variable_exp(&node),
        0x0027 => visitor.on_variable_stat(&node),
        0x0028 => visitor.on_variable_block(&node),
        0x0029 => visitor.on_variable_root(&node),
        _ => ()
    };
}
